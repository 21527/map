/* eslint-disable react/jsx-no-comment-textnodes */
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 RhinoModel0316.glb
*/

import React, { useRef } from "react";
import { useGLTF, Edges, shaderMaterial } from "@react-three/drei";
import { EffectComposer, Outline, Select } from "@react-three/postprocessing";
import { Color, ShaderMaterial } from "three";
import { useControls, folder, Leva } from "leva";
import { extend, useFrame, useThree } from "@react-three/fiber";
import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter";

const CustomCenterShaderMaterial = shaderMaterial(
  {
    time: 0,
    opacity: 0.1,
  },
  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  `
    uniform float time;
    uniform float opacity;
    void main() {
      gl_FragColor = vec4(0.8, 0.8, 0.0, opacity);
    }
    `
);
const CustomOtherShaderMaterial = shaderMaterial(
  {
    time: 0,
    opacity: 0.1,
  },
  `
    void main() {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  `
    uniform float time;
    uniform float opacity;
    void main() {
      gl_FragColor += vec4(0.5, 0.5, 0.5, 1.0) * sin(time * 2.0);
    }
    `
);

// gl_FragColor = vec4(0.1, 0.1, 0.1, opacity);

extend({ CustomCenterShaderMaterial, CustomOtherShaderMaterial });

export default function RhinoModel0316({ ...props }) {
  const { scene } = useThree();
  // exportGLTF();

  const exportGLB = () => {
    const exporter = new GLTFExporter();
    exporter.parse(
      scene,
      (gltf) => {
        const output = JSON.stringify(gltf, null, 2);
        // const output = gltf;
        console.log("output", output);
        console.log("gltf", gltf);
        console.log("scene", scene);

        const blob = new Blob([output], {
          type: "application/octet-stream",
        });
        // saveAs(blob, "scene.glb");
      },
      { binary: true }
    );
  };
  exportGLB();

  const { nodes, materials } = useGLTF("models/RhinoModel0316.glb");
  const meshes = Object.values(nodes).filter((n) => n.type === "Mesh");
  const group = useRef();
  useFrame(() => {});

  //leva GUI组件库 https://github.com/pmndrs/leva

  const config = useControls({
    Outline: folder(
      {
        center: { value: true },
        // tower: { value: true },
        building: { value: false },
      },
      { collapsed: false }
    ),
    Skirt: folder({
      skirtColor: { value: "#F0F" },
      skirtOpacity: { min: 0.0, max: 1.0, value: 0.95 },
    }),
    Tower: folder({
      towerColor: { value: "#FF0" },
      towerOpacity: { min: 0.0, max: 1.0, value: 0.95 },
    }),
  });

  // 设置模型的材质和阴影属性
  // scene.traverse((child) => {
  //   if (child.isMesh) {
  //     child.castShadow = true;
  //     child.receiveShadow = true;
  //     child.material.side = 2; // 设置材质为双面显示
  //   }
  // });

  console.log("meshes", meshes);
  console.log("nodes", nodes);
  console.log("materials", materials);
  console.log("scene", scene);

  return (
    <group ref={group} {...props} dispose={null} castShadow receiveShadow>
      //site
      <mesh
        geometry={nodes.site.geometry}
        material={materials["site"]}
        castShadow
        receiveShadow
      >
        <Edges scale={1} threshold={15} color='#F00' lineWidth={20} />
      </mesh>
      <Select enabled={config.all}>
        <Select name='center' enabled={config.center}>
          //skirt
          {meshes
            .filter((v) => v.name.includes("skirt"))
            .map((item, index) => {
              return (
                <mesh
                  key={index}
                  geometry={item.geometry}
                  castShadow
                  receiveShadow
                >
                  <meshStandardMaterial
                    transparent
                    opacity={config.skirtOpacity}
                    color={config.skirtColor}
                    // opacity={0.95}
                    // color="#F0F"
                  />
                  {/* <customOtherShaderMaterial attach="material" /> */}
                  <Edges scale={1} threshold={15} color='#000' />
                </mesh>
              );
            })}
          //tower
          {meshes
            .filter((v) => v.name.includes("tower"))
            .map((item, index) => {
              return (
                <mesh
                  key={index}
                  geometry={item.geometry}
                  castShadow
                  receiveShadow
                >
                  <meshStandardMaterial
                    transparent
                    opacity={config.towerOpacity}
                    color={config.towerColor}
                    // opacity={0.95}
                    // color="#FF0"
                  />
                  <Edges scale={1} threshold={15} color='#999' />
                </mesh>
              );
            })}
        </Select>
        <Select name='building' enabled={config.building}>
          //building
          {meshes
            .filter((v) => v.name.includes("building"))
            .map((item, index) => {
              return (
                <mesh
                  key={index}
                  geometry={item.geometry}
                  castShadow
                  receiveShadow
                >
                  <meshStandardMaterial
                    transparent
                    opacity={0.7}
                    color='#AAA'
                  />
                  {/* <customOtherShaderMaterial attach="material" /> */}
                  <Edges scale={1} threshold={15} color='#AAA' />
                </mesh>
              );
            })}
        </Select>
        <Select name='ground'>
          //ground
          {meshes
            .filter((v) => v.name.includes("ground"))
            .map((item, index) => {
              return (
                <mesh
                  key={index}
                  geometry={item.geometry}
                  castShadow
                  receiveShadow
                >
                  <meshStandardMaterial
                    transparent
                    opacity={0.7}
                    color='#AAA'
                  />
                  {/* <customOtherShaderMaterial attach="material" /> */}
                  <Edges scale={1} threshold={15} color='#AAA' />
                </mesh>
              );
            })}
        </Select>
        //ground
        <mesh
          geometry={nodes.ground.geometry}
          material={materials["ground"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.ground001.geometry}
          material={materials["ground"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.ground002.geometry}
          material={materials["ground"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.ground003.geometry}
          material={materials["ground"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.ground004.geometry}
          material={materials["ground"]}
          castShadow
          receiveShadow
        ></mesh>
        //road
        <mesh
          geometry={nodes.road.geometry}
          material={materials["road"]}
          castShadow
          receiveShadow
        ></mesh>
        //site
        <mesh
          geometry={nodes.site.geometry}
          material={materials["site"]}
          castShadow
          receiveShadow
        ></mesh>
        //water
        <mesh
          geometry={nodes.water.geometry}
          material={materials["water"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.water001.geometry}
          material={materials["water"]}
          castShadow
          receiveShadow
        ></mesh>
        //green
        <mesh
          geometry={nodes.green.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green001.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green002.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green003.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green004.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green005.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green006.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green007.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green008.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
        <mesh
          geometry={nodes.green009.geometry}
          material={materials["green"]}
          castShadow
          receiveShadow
        ></mesh>
      </Select>
      {/* <primitive
        object={scene}
        {...props}
        castShadow
        receiveShadow
        onClick={(e) => console.log("click")}
      /> */}
    </group>
  );
}

useGLTF.preload("models/RhinoModel0316.glb");
