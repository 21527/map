/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.1.4 tree.glb
*/

import React, { useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { Mesh } from "three";
import treePosition from "@/res/json/tree.json";

export function Tree(props) {
  const { nodes, materials, scene } = useGLTF("models/tree.glb");

  while (scene.children.length > 0) {
    const child = scene.children[0];
    scene.remove(child);
  }

  function createTree(x, y, z) {
    const treeMesh = new Mesh(nodes.tree1.geometry, materials["6_tree"]); // 使用之前创建的树的几何体和材质创建树的网格对象
    treeMesh.position.set(x, y, z); // 设置树的位置

    return treeMesh;
  }

  console.log("treePosition", treePosition.position);
  const treeList = treePosition.position;

  for (let i = 0; i < treeList.length; i++) {
    const x = treeList[i][0];
    // const y = treeList[i][1];
    const z = treeList[i][2];
    const tree = createTree(x, 0, z);
    tree.castShadow = true;
    tree.receiveShadow = true;
    tree.rotateX(-Math.PI / 2);
    scene.add(tree);
  }

  // const NUM_TREES = 1000; // 创建n棵树
  // for (let i = 0; i < NUM_TREES; i++) {
  //   const x = Math.random() * 500 - 250; // 随机生成x坐标
  //   const z = Math.random() * 500 - 250; // 随机生成z坐标
  //   const tree = createTree(x, 0, z); // 创建树的网格对象
  //   tree.rotateX(-Math.PI / 2);
  //   scene.add(tree); // 将树添加到场景中
  // }
  console.log("treeScene", scene);

  return (
    <group {...props} dispose={null}>
      {/* <mesh
        geometry={nodes.tree1.geometry}
        material={materials["6_tree"]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={1}
      /> */}
      <primitive
        object={scene}
        {...props}
        castShadow
        receiveShadow
        onClick={(e) => console.log("click")}
      />
    </group>
  );
}

useGLTF.preload("models/tree.glb");
